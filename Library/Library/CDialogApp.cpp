// Subclass of CWinAppEx


#include "pch.h"
#include "CDialogApp.h"
#include "MessageBox.h"
#include "ResourceData.h"


CDialogApp* theCDialogApp;


CDialogApp::CDialogApp(CDialogApp* app) {
ResourceData res;

  theCDialogApp = app;

  res.getVersion(version);

  if (res.getAppID(appID)) SetAppID(appID);   else messageBox(_T("Unable to create an appID"));

//String t;   t.format(_T("appID size = %i"), appID.length() * sizeof(Tchar));   messageBox(t);

  EnableHtmlHelp();
  }


CDialogApp::~CDialogApp() {

  appID.~String();   version.~String();

#ifdef DebugMemoryLeaks
  _CrtDumpMemoryLeaks();
#endif
  }


int CDialogApp::ExitInstance() {return CWinAppEx::ExitInstance();}


HANDLE CDialogApp::getDevMode() {
PRINTDLG pd;
HANDLE   hdl = 0;
DEVMODE* devMode;

 if (m_hDevMode) return m_hDevMode;

  memset(&pd, 0, sizeof(PRINTDLG));   pd.lStructSize = sizeof(PRINTDLG);

  if (!GetPrinterDeviceDefaults(&pd))
       {messageBox(_T("Default printer drivers are damaged, try reinstalling drivers")); return 0;}

  hdl = pd.hDevMode;
  devMode = (DEVMODE*) GlobalLock(hdl);               // Protect memory handle with ::GlobalLock

    if (devMode->dmFields & DM_ORIENTATION) devMode->dmOrientation = PortOrient;
    if (devMode->dmFields & DM_PAPERSIZE)   devMode->dmPaperSize   = LetterPprSz;
    if (devMode->dmFields & DM_COPIES)      devMode->dmCopies      = 1;
    if (devMode->dmFields & DM_COLLATE)     devMode->dmCollate     = 1;
    if (devMode->dmFields & DM_DUPLEX)      devMode->dmDuplex      = SimPlex;

  GlobalUnlock(hdl);   return hdl;
  }

/*

The following memory leak dump appears to be generated by MFC either performing the dump or some
other exercise.

Dumping objects ->
D:\a\_work\1\s\src\vctools\VC7Libs\Ship\ATLMFC\Src\MFC\strcore.cpp(156) : {311} normal block at
0x00FE9990, 36 bytes long.
 Data: <H 8{            > 48 96 38 7B 09 00 00 00 09 00 00 00 01 00 00 00

{310} client block at 0x00FFDC28, subtype c0, 12 bytes long.

D:\a\_work\1\s\src\vctools\VC7Libs\Ship\ATLMFC\Src\MFC\dumpcont.cpp(23) : atlTraceGeneral - a
CObject object at $00FFDC28, 12 bytes long

{309} normal block at 0x00FFD6B0, 8 bytes long.
 Data: <        > C4 D8 E8 00 00 00 00 00

{308} normal block at 0x00FFD800, 8 bytes long.
 Data: <P       > 50 D8 E8 00 00 00 00 00

{304} normal block at 0x00FFD838, 8 bytes long.
 Data: <        > C8 D6 E8 00 00 00 00 00

{123} client block at 0x00FF9E00, subtype c0, 64 bytes long.

D:\a\_work\1\s\src\vctools\VC7Libs\Ship\ATLMFC\Src\MFC\dumpcont.cpp(23) : atlTraceGeneral -
a CDynLinkLibrary object at $00FF9E00, 64 bytes long

Object dump complete.
*/

/*
Find memory leaks with the CRT Library - Visual Studio | Microsoft
  https://docs.microsoft.com/en-us/visualstudio/debugger/finding-memory-leaks-using-the-crt-library?view=vs-2019

Memory leaks are incidious.  Here is some help for finding them.  Look at framework.h for turning
on the facilities needed for the following to work.  Must be turned on in all projects.

  #ifdef DebugMemoryLeaks
  #define _CRTDBG_MAP_ALLOC
  #include <crtdbg.h>
  #endif

If your app doesn't define _CRTDBG_MAP_ALLOC , _CrtDumpMemoryLeaks displays a memory-leak report
that looks like:

  Detected memory leaks!
  Dumping objects ?>
  {18} normal block at 0x00780E80, 64 bytes long.
   Data: < > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
  Object dump complete.

If your app defines _CRTDBG_MAP_ALLOC , the memory-leak report looks like:

  Detected memory leaks!
  Dumping objects ?>
  c:\users\username\documents\projects\leaktest\leaktest.cpp(20) : {18}
  normal block at 0x00780E80, 64 bytes long.
   Data: < > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD
  Object dump complete.

The second report shows the filename and line number where the leaked memory is first allocated.

Whether or not you define _CRTDBG_MAP_ALLOC , the memory-leak report displays:

  * The memory allocation number, which is 18 in the example
  * The block type, normal in the example.
  * The hexadecimal memory location, 0x00780E80 in the example.
  * The size of the block, 64 bytes in the example.
  * The first 16 bytes of data in the block, in hexadecimal form.

Memory block types are normal, client, or CRT. A normal block is ordinary memory allocated by your
program. A client block is a special type of memory block used by MFC programs for objects that
require a destructor. The MFC new operator creates either a normal block or a client block, as
appropriate for the object being created.

A CRT block is allocated by the CRT library for its own use. The CRT library handles the
deallocation for these blocks, so CRT blocks won't appear in the memory-leak report unless there
are serious problems with the CRT library.

There are two other types of memory blocks that never appear in memory-leak reports. A free block
is memory that has been released, so by definition isn't leaked. An ignore block is memory that
you've explicitly marked to exclude from the memory-leak report.

// Just a quick note:  The module NewAllocator defines some macros for displaying the location of
// each allocation of memory performed by the program.  The bug that required this note and
// additional debugging capability came about because the programmed initialized a string twice
// throwing away the memory allocated for the first initialization.  This was very hard to find
// since the location was not recorded but the allocation number (count of the number of
// allocations) was recorded and that allowed the problem to be found.  It was easy to fix, hard to
// find.

Setting Breakpoints on a memory allocation number

The memory allocation number tells you when a leaked memory block was allocated. A block with a
memory allocation number of 18, for example, is the 18th block of memory allocated during the run
of the app.  The CRT report counts all memory-block allocations during the run, including
allocations by the CRT library and other libraries such as MFC. Therefore, memory allocation block
number 18 probably isn't the 18th memory block allocated by your code.

You can use the allocation number to set a breakpoint on the memory allocation.

To set a memory-allocation breakpoint using the Watch window:

  1. Set a breakpoint near the start of your app, and start debugging.

  2. When the app pauses at the breakpoint, open a Watch window by selecting
     Debug > Windows > Watch 1 (or Watch 2, Watch 3, or Watch 4).

  3. In the Watch window, type _crtBreakAlloc in the Name column.

     If you're using the multithreaded DLL version of the CRT library (the /MD option), add the
     context operator:  {,,ucrtbased.dll}_crtBreakAlloc

     Make sure that debug symbols are loaded. Otherwise _crtBreakAlloc will be reported as
     unidentified.

  4. Press Enter.

     The debugger evaluates the call and places the result in the Value column. This value will
     be -1 if you have not set any breakpoints on memory allocations.

  5. In the Value column, replace the value with the allocation number of the memory allocation
     where you want the debugger to break.

After you set a breakpoint on a memory-allocation number, continue to debug. Make sure to run under
the same conditions, so the memory-allocation number doesn't change. When your program breaks at
the specified memory allocation, use the Call Stack window and other debugger windows to determine
the conditions under which the memory was allocated. Then, you can continue execution to observe
what happens to the object and determine why it isn't correctly deallocated.

Setting a data breakpoint on the object might also be helpful. For more information, see Using
breakpoints.

You can also set memory-allocation breakpoints in code. You can set:

  _crtBreakAlloc = 18;

or

  _CrtSetBreakAlloc(18);
*/






/////////-------------------

