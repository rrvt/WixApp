// Created by Microsoft (R) C/C++ Compiler Version 14.16.27045.0 (a6f52b41).
//
// d:\sources\codegenii\debug\library\acedao.tli
//
// Wrapper implementations for Win32 type library C:\Program Files (x86)\Microsoft Office\root\Office16\ACEDAO.DLL
// compiler-generated file created 04/02/21 at 18:09:30 - DO NOT EDIT!

#pragma once

//
// interface _Collection wrapper method implementations
//

inline short _Collection::GetCount ( ) {
    short _result = 0;
    HRESULT _hr = get_Count(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline IUnknownPtr _Collection::_NewEnum ( ) {
    IUnknown * _result = 0;
    HRESULT _hr = raw__NewEnum(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IUnknownPtr(_result, false);
}

inline HRESULT _Collection::Refresh ( ) {
    HRESULT _hr = raw_Refresh();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _DynaCollection wrapper method implementations
//

inline HRESULT _DynaCollection::Append ( IDispatch * Object ) {
    HRESULT _hr = raw_Append(Object);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DynaCollection::Delete ( _bstr_t Name ) {
    HRESULT _hr = raw_Delete(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface TableDefs wrapper method implementations
//

inline _TableDefPtr TableDefs::GetItem ( const _variant_t & Item ) {
    struct _TableDef * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TableDefPtr(_result, false);
}

//
// interface Fields wrapper method implementations
//

inline _FieldPtr Fields::GetItem ( const _variant_t & Item ) {
    struct _Field * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldPtr(_result, false);
}

//
// interface Indexes wrapper method implementations
//

inline _IndexPtr Indexes::GetItem ( const _variant_t & Item ) {
    struct _Index * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _IndexPtr(_result, false);
}

//
// interface QueryDefs wrapper method implementations
//

inline _QueryDefPtr QueryDefs::GetItem ( const _variant_t & Item ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

//
// interface Relations wrapper method implementations
//

inline _RelationPtr Relations::GetItem ( const _variant_t & Item ) {
    struct _Relation * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _RelationPtr(_result, false);
}

//
// interface Users wrapper method implementations
//

inline _UserPtr Users::GetItem ( const _variant_t & Item ) {
    struct _User * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _UserPtr(_result, false);
}

//
// interface Groups wrapper method implementations
//

inline _GroupPtr Groups::GetItem ( const _variant_t & Item ) {
    struct _Group * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _GroupPtr(_result, false);
}

//
// interface Error wrapper method implementations
//

inline long Error::GetNumber ( ) {
    long _result = 0;
    HRESULT _hr = get_Number(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Error::GetSource ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Source(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Error::GetDescription ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Description(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Error::GetHelpFile ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_HelpFile(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long Error::GetHelpContext ( ) {
    long _result = 0;
    HRESULT _hr = get_HelpContext(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Errors wrapper method implementations
//

inline ErrorPtr Errors::GetItem ( const _variant_t & Item ) {
    struct Error * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ErrorPtr(_result, false);
}

//
// interface ComplexType wrapper method implementations
//

inline FieldsPtr ComplexType::GetFields ( ) {
    struct Fields * _result = 0;
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FieldsPtr(_result, false);
}

//
// interface IndexFields wrapper method implementations
//

inline _variant_t IndexFields::GetItem ( const _variant_t & Item ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

//
// interface _DAO wrapper method implementations
//

inline PropertiesPtr _DAO::GetProperties ( ) {
    struct Properties * _result = 0;
    HRESULT _hr = get_Properties(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertiesPtr(_result, false);
}

//
// interface Property wrapper method implementations
//

inline _variant_t Property::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void Property::PutValue ( const _variant_t & pval ) {
    HRESULT _hr = put_Value(pval);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Property::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Property::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Property::GetType ( ) {
    short _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Property::PutType ( short ptype ) {
    HRESULT _hr = put_Type(ptype);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Property::GetInherited ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Inherited(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Properties wrapper method implementations
//

inline PropertyPtr Properties::GetItem ( const _variant_t & Item ) {
    struct Property * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

//
// interface _Field wrapper method implementations
//

inline long _Field::GetCollatingOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_CollatingOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline short _Field::GetType ( ) {
    short _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutType ( short ps ) {
    HRESULT _hr = put_Type(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Field::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Field::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _Field::GetSize ( ) {
    long _result = 0;
    HRESULT _hr = get_Size(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutSize ( long pl ) {
    HRESULT _hr = put_Size(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Field::GetSourceField ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SourceField(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _Field::GetSourceTable ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SourceTable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t _Field::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void _Field::PutValue ( const _variant_t & pvar ) {
    HRESULT _hr = put_Value(pvar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _Field::GetAttributes ( ) {
    long _result = 0;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutAttributes ( long pl ) {
    HRESULT _hr = put_Attributes(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short _Field::GetOrdinalPosition ( ) {
    short _result = 0;
    HRESULT _hr = get_OrdinalPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutOrdinalPosition ( short ps ) {
    HRESULT _hr = put_OrdinalPosition(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Field::GetValidationText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Field::PutValidationText ( _bstr_t pbstr ) {
    HRESULT _hr = put_ValidationText(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Field::GetValidateOnSet ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ValidateOnSet(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutValidateOnSet ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_ValidateOnSet(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Field::GetValidationRule ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationRule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Field::PutValidationRule ( _bstr_t pbstr ) {
    HRESULT _hr = put_ValidationRule(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t _Field::GetDefaultValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_DefaultValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void _Field::PutDefaultValue ( const _variant_t & pvar ) {
    HRESULT _hr = put_DefaultValue(pvar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Field::GetRequired ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Required(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutRequired ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Required(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Field::GetAllowZeroLength ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AllowZeroLength(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Field::PutAllowZeroLength ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_AllowZeroLength(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Field::GetDataUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DataUpdatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _Field::GetForeignName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ForeignName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Field::PutForeignName ( _bstr_t pbstr ) {
    HRESULT _hr = put_ForeignName(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT _Field::AppendChunk ( const _variant_t & Val ) {
    HRESULT _hr = raw_AppendChunk(Val);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _variant_t _Field::GetChunk ( long Offset, long Bytes ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetChunk(Offset, Bytes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long _Field::_30_FieldSize ( ) {
    long _result = 0;
    HRESULT _hr = raw__30_FieldSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline PropertyPtr _Field::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

inline short _Field::GetCollectionIndex ( ) {
    short _result = 0;
    HRESULT _hr = get_CollectionIndex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _Field::GetOriginalValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_OriginalValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _Field::GetVisibleValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_VisibleValue(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long _Field::GetFieldSize ( ) {
    long _result = 0;
    HRESULT _hr = get_FieldSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface _Index wrapper method implementations
//

inline _bstr_t _Index::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Index::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Index::GetForeign ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Foreign(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL _Index::GetUnique ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Unique(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Index::PutUnique ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Unique(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Index::GetClustered ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Clustered(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Index::PutClustered ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Clustered(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Index::GetRequired ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Required(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Index::PutRequired ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Required(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Index::GetIgnoreNulls ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IgnoreNulls(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Index::PutIgnoreNulls ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_IgnoreNulls(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _Index::GetPrimary ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Primary(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Index::PutPrimary ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Primary(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _Index::GetDistinctCount ( ) {
    long _result = 0;
    HRESULT _hr = get_DistinctCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t _Index::GetFields ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void _Index::PutFields ( const _variant_t & pv ) {
    HRESULT _hr = put_Fields(pv);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _FieldPtr _Index::CreateField ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Size ) {
    struct _Field * _result = 0;
    HRESULT _hr = raw_CreateField(Name, Type, Size, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldPtr(_result, false);
}

inline PropertyPtr _Index::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

//
// interface Parameter wrapper method implementations
//

inline _bstr_t Parameter::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t Parameter::GetValue ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Value(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void Parameter::PutValue ( const _variant_t & pvar ) {
    HRESULT _hr = put_Value(pvar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Parameter::GetType ( ) {
    short _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Parameter::PutType ( short ps ) {
    HRESULT _hr = put_Type(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Parameter::GetDirection ( ) {
    short _result = 0;
    HRESULT _hr = get_Direction(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Parameter::PutDirection ( short pOption ) {
    HRESULT _hr = put_Direction(pOption);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Parameters wrapper method implementations
//

inline ParameterPtr Parameters::GetItem ( const _variant_t & Item ) {
    struct Parameter * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ParameterPtr(_result, false);
}

//
// interface _Relation wrapper method implementations
//

inline _bstr_t _Relation::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Relation::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Relation::GetTable ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Table(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Relation::PutTable ( _bstr_t pbstr ) {
    HRESULT _hr = put_Table(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _Relation::GetForeignTable ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ForeignTable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Relation::PutForeignTable ( _bstr_t pbstr ) {
    HRESULT _hr = put_ForeignTable(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _Relation::GetAttributes ( ) {
    long _result = 0;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Relation::PutAttributes ( long pl ) {
    HRESULT _hr = put_Attributes(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline FieldsPtr _Relation::GetFields ( ) {
    struct Fields * _result = 0;
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FieldsPtr(_result, false);
}

inline _FieldPtr _Relation::CreateField ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Size ) {
    struct _Field * _result = 0;
    HRESULT _hr = raw_CreateField(Name, Type, Size, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldPtr(_result, false);
}

inline VARIANT_BOOL _Relation::GetPartialReplica ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_PartialReplica(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _Relation::PutPartialReplica ( VARIANT_BOOL pfPartialReplica ) {
    HRESULT _hr = put_PartialReplica(pfPartialReplica);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Document wrapper method implementations
//

inline _bstr_t Document::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Document::GetOwner ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Owner(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Document::PutOwner ( _bstr_t pbstr ) {
    HRESULT _hr = put_Owner(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Document::GetContainer ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Container(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Document::GetUserName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Document::PutUserName ( _bstr_t pbstr ) {
    HRESULT _hr = put_UserName(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Document::GetPermissions ( ) {
    long _result = 0;
    HRESULT _hr = get_Permissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Document::PutPermissions ( long pl ) {
    HRESULT _hr = put_Permissions(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t Document::GetDateCreated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_DateCreated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t Document::GetLastUpdated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_LastUpdated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline long Document::GetAllPermissions ( ) {
    long _result = 0;
    HRESULT _hr = get_AllPermissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline PropertyPtr Document::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

//
// interface Documents wrapper method implementations
//

inline DocumentPtr Documents::GetItem ( const _variant_t & Item ) {
    struct Document * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DocumentPtr(_result, false);
}

//
// interface Container wrapper method implementations
//

inline _bstr_t Container::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Container::GetOwner ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Owner(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Container::PutOwner ( _bstr_t pbstr ) {
    HRESULT _hr = put_Owner(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Container::GetUserName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Container::PutUserName ( _bstr_t pbstr ) {
    HRESULT _hr = put_UserName(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Container::GetPermissions ( ) {
    long _result = 0;
    HRESULT _hr = get_Permissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Container::PutPermissions ( long pl ) {
    HRESULT _hr = put_Permissions(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Container::GetInherit ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Inherit(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Container::PutInherit ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_Inherit(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline DocumentsPtr Container::GetDocuments ( ) {
    struct Documents * _result = 0;
    HRESULT _hr = get_Documents(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DocumentsPtr(_result, false);
}

inline long Container::GetAllPermissions ( ) {
    long _result = 0;
    HRESULT _hr = get_AllPermissions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

//
// interface Containers wrapper method implementations
//

inline ContainerPtr Containers::GetItem ( const _variant_t & Item ) {
    struct Container * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ContainerPtr(_result, false);
}

//
// interface _User wrapper method implementations
//

inline _bstr_t _User::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _User::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void _User::PutPID ( _bstr_t _arg1 ) {
    HRESULT _hr = put_PID(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void _User::PutPassword ( _bstr_t _arg1 ) {
    HRESULT _hr = put_Password(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline GroupsPtr _User::GetGroups ( ) {
    struct Groups * _result = 0;
    HRESULT _hr = get_Groups(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return GroupsPtr(_result, false);
}

inline HRESULT _User::NewPassword ( _bstr_t bstrOld, _bstr_t bstrNew ) {
    HRESULT _hr = raw_NewPassword(bstrOld, bstrNew);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _GroupPtr _User::CreateGroup ( const _variant_t & Name, const _variant_t & PID ) {
    struct _Group * _result = 0;
    HRESULT _hr = raw_CreateGroup(Name, PID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _GroupPtr(_result, false);
}

//
// interface _Group wrapper method implementations
//

inline _bstr_t _Group::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _Group::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void _Group::PutPID ( _bstr_t _arg1 ) {
    HRESULT _hr = put_PID(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline UsersPtr _Group::GetUsers ( ) {
    struct Users * _result = 0;
    HRESULT _hr = get_Users(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UsersPtr(_result, false);
}

inline _UserPtr _Group::CreateUser ( const _variant_t & Name, const _variant_t & PID, const _variant_t & Password ) {
    struct _User * _result = 0;
    HRESULT _hr = raw_CreateUser(Name, PID, Password, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _UserPtr(_result, false);
}

//
// interface Field2 wrapper method implementations
//

inline ComplexTypePtr Field2::GetComplexType ( ) {
    struct ComplexType * _result = 0;
    HRESULT _hr = get_ComplexType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ComplexTypePtr(_result, false);
}

inline HRESULT Field2::LoadFromFile ( _bstr_t FileName ) {
    HRESULT _hr = raw_LoadFromFile(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Field2::SaveToFile ( _bstr_t FileName ) {
    HRESULT _hr = raw_SaveToFile(FileName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL Field2::GetIsComplex ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_IsComplex(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Field2::GetAppendOnly ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_AppendOnly(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Field2::PutAppendOnly ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_AppendOnly(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Field2::GetExpression ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Expression(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Field2::PutExpression ( _bstr_t pbstr ) {
    HRESULT _hr = put_Expression(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface _DBEngine wrapper method implementations
//

inline _bstr_t _DBEngine::GetVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t _DBEngine::GetIniPath ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_IniPath(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _DBEngine::PutIniPath ( _bstr_t pbstr ) {
    HRESULT _hr = put_IniPath(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void _DBEngine::PutDefaultUser ( _bstr_t _arg1 ) {
    HRESULT _hr = put_DefaultUser(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void _DBEngine::PutDefaultPassword ( _bstr_t _arg1 ) {
    HRESULT _hr = put_DefaultPassword(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short _DBEngine::GetLoginTimeout ( ) {
    short _result = 0;
    HRESULT _hr = get_LoginTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _DBEngine::PutLoginTimeout ( short ps ) {
    HRESULT _hr = put_LoginTimeout(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline WorkspacesPtr _DBEngine::GetWorkspaces ( ) {
    struct Workspaces * _result = 0;
    HRESULT _hr = get_Workspaces(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspacesPtr(_result, false);
}

inline ErrorsPtr _DBEngine::GetErrors ( ) {
    struct Errors * _result = 0;
    HRESULT _hr = get_Errors(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ErrorsPtr(_result, false);
}

inline HRESULT _DBEngine::Idle ( const _variant_t & Action ) {
    HRESULT _hr = raw_Idle(Action);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::CompactDatabase ( _bstr_t SrcName, _bstr_t DstName, const _variant_t & DstLocale, const _variant_t & Options, const _variant_t & SrcLocale ) {
    HRESULT _hr = raw_CompactDatabase(SrcName, DstName, DstLocale, Options, SrcLocale);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::RepairDatabase ( _bstr_t Name ) {
    HRESULT _hr = raw_RepairDatabase(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::RegisterDatabase ( _bstr_t Dsn, _bstr_t Driver, VARIANT_BOOL Silent, _bstr_t Attributes ) {
    HRESULT _hr = raw_RegisterDatabase(Dsn, Driver, Silent, Attributes);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline WorkspacePtr _DBEngine::_30_CreateWorkspace ( _bstr_t Name, _bstr_t UserName, _bstr_t Password ) {
    struct Workspace * _result = 0;
    HRESULT _hr = raw__30_CreateWorkspace(Name, UserName, Password, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspacePtr(_result, false);
}

inline DatabasePtr _DBEngine::OpenDatabase ( _bstr_t Name, const _variant_t & Options, const _variant_t & ReadOnly, const _variant_t & Connect ) {
    struct Database * _result = 0;
    HRESULT _hr = raw_OpenDatabase(Name, Options, ReadOnly, Connect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline DatabasePtr _DBEngine::CreateDatabase ( _bstr_t Name, _bstr_t Locale, const _variant_t & Option ) {
    struct Database * _result = 0;
    HRESULT _hr = raw_CreateDatabase(Name, Locale, Option, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline HRESULT _DBEngine::FreeLocks ( ) {
    HRESULT _hr = raw_FreeLocks();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::BeginTrans ( ) {
    HRESULT _hr = raw_BeginTrans();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::CommitTrans ( long Option ) {
    HRESULT _hr = raw_CommitTrans(Option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::Rollback ( ) {
    HRESULT _hr = raw_Rollback();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::SetDefaultWorkspace ( _bstr_t Name, _bstr_t Password ) {
    HRESULT _hr = raw_SetDefaultWorkspace(Name, Password);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _DBEngine::SetDataAccessOption ( short Option, const _variant_t & Value ) {
    HRESULT _hr = raw_SetDataAccessOption(Option, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long _DBEngine::ISAMStats ( long StatNum, const _variant_t & Reset ) {
    long _result = 0;
    HRESULT _hr = raw_ISAMStats(StatNum, Reset, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _DBEngine::GetSystemDB ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SystemDB(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _DBEngine::PutSystemDB ( _bstr_t pbstr ) {
    HRESULT _hr = put_SystemDB(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline WorkspacePtr _DBEngine::CreateWorkspace ( _bstr_t Name, _bstr_t UserName, _bstr_t Password, const _variant_t & UseType ) {
    struct Workspace * _result = 0;
    HRESULT _hr = raw_CreateWorkspace(Name, UserName, Password, UseType, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspacePtr(_result, false);
}

inline ConnectionPtr _DBEngine::OpenConnection ( _bstr_t Name, const _variant_t & Options, const _variant_t & ReadOnly, const _variant_t & Connect ) {
    struct Connection * _result = 0;
    HRESULT _hr = raw_OpenConnection(Name, Options, ReadOnly, Connect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionPtr(_result, false);
}

inline long _DBEngine::GetDefaultType ( ) {
    long _result = 0;
    HRESULT _hr = get_DefaultType(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _DBEngine::PutDefaultType ( long Option ) {
    HRESULT _hr = put_DefaultType(Option);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT _DBEngine::SetOption ( long Option, const _variant_t & Value ) {
    HRESULT _hr = raw_SetOption(Option, Value);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface Workspaces wrapper method implementations
//

inline WorkspacePtr Workspaces::GetItem ( const _variant_t & Item ) {
    struct Workspace * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return WorkspacePtr(_result, false);
}

//
// interface Workspace wrapper method implementations
//

inline _bstr_t Workspace::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Workspace::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Workspace::GetUserName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_UserName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Workspace::Put_30_UserName ( _bstr_t _arg1 ) {
    HRESULT _hr = put__30_UserName(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline void Workspace::Put_30_Password ( _bstr_t _arg1 ) {
    HRESULT _hr = put__30_Password(_arg1);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Workspace::GetIsolateODBCTrans ( ) {
    short _result = 0;
    HRESULT _hr = get_IsolateODBCTrans(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Workspace::PutIsolateODBCTrans ( short ps ) {
    HRESULT _hr = put_IsolateODBCTrans(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline DatabasesPtr Workspace::GetDatabases ( ) {
    struct Databases * _result = 0;
    HRESULT _hr = get_Databases(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasesPtr(_result, false);
}

inline UsersPtr Workspace::GetUsers ( ) {
    struct Users * _result = 0;
    HRESULT _hr = get_Users(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return UsersPtr(_result, false);
}

inline GroupsPtr Workspace::GetGroups ( ) {
    struct Groups * _result = 0;
    HRESULT _hr = get_Groups(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return GroupsPtr(_result, false);
}

inline HRESULT Workspace::BeginTrans ( ) {
    HRESULT _hr = raw_BeginTrans();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Workspace::CommitTrans ( long Options ) {
    HRESULT _hr = raw_CommitTrans(Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Workspace::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Workspace::Rollback ( ) {
    HRESULT _hr = raw_Rollback();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline DatabasePtr Workspace::OpenDatabase ( _bstr_t Name, const _variant_t & Options, const _variant_t & ReadOnly, const _variant_t & Connect ) {
    struct Database * _result = 0;
    HRESULT _hr = raw_OpenDatabase(Name, Options, ReadOnly, Connect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline DatabasePtr Workspace::CreateDatabase ( _bstr_t Name, _bstr_t Connect, const _variant_t & Option ) {
    struct Database * _result = 0;
    HRESULT _hr = raw_CreateDatabase(Name, Connect, Option, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline _UserPtr Workspace::CreateUser ( const _variant_t & Name, const _variant_t & PID, const _variant_t & Password ) {
    struct _User * _result = 0;
    HRESULT _hr = raw_CreateUser(Name, PID, Password, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _UserPtr(_result, false);
}

inline _GroupPtr Workspace::CreateGroup ( const _variant_t & Name, const _variant_t & PID ) {
    struct _Group * _result = 0;
    HRESULT _hr = raw_CreateGroup(Name, PID, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _GroupPtr(_result, false);
}

inline ConnectionPtr Workspace::OpenConnection ( _bstr_t Name, const _variant_t & Options, const _variant_t & ReadOnly, const _variant_t & Connect ) {
    struct Connection * _result = 0;
    HRESULT _hr = raw_OpenConnection(Name, Options, ReadOnly, Connect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionPtr(_result, false);
}

inline long Workspace::GetLoginTimeout ( ) {
    long _result = 0;
    HRESULT _hr = get_LoginTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Workspace::PutLoginTimeout ( long pTimeout ) {
    HRESULT _hr = put_LoginTimeout(pTimeout);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Workspace::GetDefaultCursorDriver ( ) {
    long _result = 0;
    HRESULT _hr = get_DefaultCursorDriver(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Workspace::PutDefaultCursorDriver ( long pCursorType ) {
    HRESULT _hr = put_DefaultCursorDriver(pCursorType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Workspace::GethEnv ( ) {
    long _result = 0;
    HRESULT _hr = get_hEnv(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Workspace::GetType ( ) {
    long _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline ConnectionsPtr Workspace::GetConnections ( ) {
    struct Connections * _result = 0;
    HRESULT _hr = get_Connections(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionsPtr(_result, false);
}

//
// interface Databases wrapper method implementations
//

inline DatabasePtr Databases::GetItem ( const _variant_t & Item ) {
    struct Database * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

//
// interface Database wrapper method implementations
//

inline long Database::GetCollatingOrder ( ) {
    long _result = 0;
    HRESULT _hr = get_CollatingOrder(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Database::GetConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Connect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Database::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline short Database::GetQueryTimeout ( ) {
    short _result = 0;
    HRESULT _hr = get_QueryTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Database::PutQueryTimeout ( short ps ) {
    HRESULT _hr = put_QueryTimeout(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Database::GetTransactions ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Transactions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Database::GetUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Updatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Database::GetVersion ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Version(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline long Database::GetRecordsAffected ( ) {
    long _result = 0;
    HRESULT _hr = get_RecordsAffected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline TableDefsPtr Database::GetTableDefs ( ) {
    struct TableDefs * _result = 0;
    HRESULT _hr = get_TableDefs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return TableDefsPtr(_result, false);
}

inline QueryDefsPtr Database::GetQueryDefs ( ) {
    struct QueryDefs * _result = 0;
    HRESULT _hr = get_QueryDefs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return QueryDefsPtr(_result, false);
}

inline RelationsPtr Database::GetRelations ( ) {
    struct Relations * _result = 0;
    HRESULT _hr = get_Relations(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RelationsPtr(_result, false);
}

inline ContainersPtr Database::GetContainers ( ) {
    struct Containers * _result = 0;
    HRESULT _hr = get_Containers(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ContainersPtr(_result, false);
}

inline RecordsetsPtr Database::GetRecordsets ( ) {
    struct Recordsets * _result = 0;
    HRESULT _hr = get_Recordsets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetsPtr(_result, false);
}

inline HRESULT Database::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Database::Execute ( _bstr_t Query, const _variant_t & Options ) {
    HRESULT _hr = raw_Execute(Query, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Database::_30_OpenRecordset ( _bstr_t Name, const _variant_t & Type, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw__30_OpenRecordset(Name, Type, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline PropertyPtr Database::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

inline _RelationPtr Database::CreateRelation ( const _variant_t & Name, const _variant_t & Table, const _variant_t & ForeignTable, const _variant_t & Attributes ) {
    struct _Relation * _result = 0;
    HRESULT _hr = raw_CreateRelation(Name, Table, ForeignTable, Attributes, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _RelationPtr(_result, false);
}

inline _TableDefPtr Database::CreateTableDef ( const _variant_t & Name, const _variant_t & Attributes, const _variant_t & SourceTableName, const _variant_t & Connect ) {
    struct _TableDef * _result = 0;
    HRESULT _hr = raw_CreateTableDef(Name, Attributes, SourceTableName, Connect, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _TableDefPtr(_result, false);
}

inline HRESULT Database::BeginTrans ( ) {
    HRESULT _hr = raw_BeginTrans();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Database::CommitTrans ( long Options ) {
    HRESULT _hr = raw_CommitTrans(Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Database::Rollback ( ) {
    HRESULT _hr = raw_Rollback();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Database::CreateDynaset ( _bstr_t Name, const _variant_t & Options, const _variant_t & Inconsistent ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateDynaset(Name, Options, Inconsistent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _QueryDefPtr Database::CreateQueryDef ( const _variant_t & Name, const _variant_t & SQLText ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = raw_CreateQueryDef(Name, SQLText, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

inline RecordsetPtr Database::CreateSnapshot ( _bstr_t Source, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateSnapshot(Source, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline HRESULT Database::DeleteQueryDef ( _bstr_t Name ) {
    HRESULT _hr = raw_DeleteQueryDef(Name);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long Database::ExecuteSQL ( _bstr_t SQL ) {
    long _result = 0;
    HRESULT _hr = raw_ExecuteSQL(SQL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline RecordsetPtr Database::ListFields ( _bstr_t Name ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_ListFields(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr Database::ListTables ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_ListTables(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _QueryDefPtr Database::OpenQueryDef ( _bstr_t Name ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = raw_OpenQueryDef(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

inline RecordsetPtr Database::OpenTable ( _bstr_t Name, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenTable(Name, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _bstr_t Database::GetReplicaID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ReplicaID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Database::GetDesignMasterID ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_DesignMasterID(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Database::PutDesignMasterID ( _bstr_t pbstr ) {
    HRESULT _hr = put_DesignMasterID(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT Database::Synchronize ( _bstr_t DbPathName, const _variant_t & ExchangeType ) {
    HRESULT _hr = raw_Synchronize(DbPathName, ExchangeType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Database::MakeReplica ( _bstr_t PathName, _bstr_t Description, const _variant_t & Options ) {
    HRESULT _hr = raw_MakeReplica(PathName, Description, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline void Database::PutConnect ( _bstr_t pbstr ) {
    HRESULT _hr = put_Connect(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT Database::NewPassword ( _bstr_t bstrOld, _bstr_t bstrNew ) {
    HRESULT _hr = raw_NewPassword(bstrOld, bstrNew);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Database::OpenRecordset ( _bstr_t Name, const _variant_t & Type, const _variant_t & Options, const _variant_t & LockEdit ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenRecordset(Name, Type, Options, LockEdit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline ConnectionPtr Database::GetConnection ( ) {
    struct Connection * _result = 0;
    HRESULT _hr = get_Connection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionPtr(_result, false);
}

inline HRESULT Database::PopulatePartial ( _bstr_t DbPathName ) {
    HRESULT _hr = raw_PopulatePartial(DbPathName);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _TableDef wrapper method implementations
//

inline long _TableDef::GetAttributes ( ) {
    long _result = 0;
    HRESULT _hr = get_Attributes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _TableDef::PutAttributes ( long pl ) {
    HRESULT _hr = put_Attributes(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _TableDef::GetConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Connect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _TableDef::PutConnect ( _bstr_t pbstr ) {
    HRESULT _hr = put_Connect(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t _TableDef::GetDateCreated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_DateCreated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _TableDef::GetLastUpdated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_LastUpdated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _bstr_t _TableDef::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _TableDef::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _TableDef::GetSourceTableName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SourceTableName(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _TableDef::PutSourceTableName ( _bstr_t pbstr ) {
    HRESULT _hr = put_SourceTableName(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _TableDef::GetUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Updatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _TableDef::GetValidationText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _TableDef::PutValidationText ( _bstr_t pbstr ) {
    HRESULT _hr = put_ValidationText(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t _TableDef::GetValidationRule ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationRule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _TableDef::PutValidationRule ( _bstr_t pbstr ) {
    HRESULT _hr = put_ValidationRule(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _TableDef::GetRecordCount ( ) {
    long _result = 0;
    HRESULT _hr = get_RecordCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline FieldsPtr _TableDef::GetFields ( ) {
    struct Fields * _result = 0;
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FieldsPtr(_result, false);
}

inline IndexesPtr _TableDef::GetIndexes ( ) {
    struct Indexes * _result = 0;
    HRESULT _hr = get_Indexes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IndexesPtr(_result, false);
}

inline RecordsetPtr _TableDef::OpenRecordset ( const _variant_t & Type, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenRecordset(Type, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline HRESULT _TableDef::RefreshLink ( ) {
    HRESULT _hr = raw_RefreshLink();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _FieldPtr _TableDef::CreateField ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Size ) {
    struct _Field * _result = 0;
    HRESULT _hr = raw_CreateField(Name, Type, Size, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _FieldPtr(_result, false);
}

inline _IndexPtr _TableDef::CreateIndex ( const _variant_t & Name ) {
    struct _Index * _result = 0;
    HRESULT _hr = raw_CreateIndex(Name, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _IndexPtr(_result, false);
}

inline PropertyPtr _TableDef::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

inline _bstr_t _TableDef::GetConflictTable ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ConflictTable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _variant_t _TableDef::GetReplicaFilter ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_ReplicaFilter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void _TableDef::PutReplicaFilter ( const _variant_t & pFilter ) {
    HRESULT _hr = put_ReplicaFilter(pFilter);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Recordset wrapper method implementations
//

inline VARIANT_BOOL Recordset::GetBOF ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_BOF(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline SAFEARRAY * Recordset::GetBookmark ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_Bookmark(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutBookmark ( SAFEARRAY * * ppsach ) {
    HRESULT _hr = put_Bookmark(ppsach);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Recordset::GetBookmarkable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Bookmarkable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t Recordset::GetDateCreated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_DateCreated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL Recordset::GetDaoEof ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_DaoEof(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Recordset::GetFilter ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Filter(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Recordset::PutFilter ( _bstr_t pbstr ) {
    HRESULT _hr = put_Filter(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Recordset::GetIndex ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Index(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Recordset::PutIndex ( _bstr_t pbstr ) {
    HRESULT _hr = put_Index(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline SAFEARRAY * Recordset::GetLastModified ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_LastModified(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t Recordset::GetLastUpdated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_LastUpdated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline VARIANT_BOOL Recordset::GetLockEdits ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_LockEdits(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutLockEdits ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_LockEdits(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _bstr_t Recordset::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline VARIANT_BOOL Recordset::GetNoMatch ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_NoMatch(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Recordset::GetSort ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Sort(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void Recordset::PutSort ( _bstr_t pbstr ) {
    HRESULT _hr = put_Sort(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Recordset::GetTransactions ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Transactions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline short Recordset::GetType ( ) {
    short _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GetRecordCount ( ) {
    long _result = 0;
    HRESULT _hr = get_RecordCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Recordset::GetUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Updatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Recordset::GetRestartable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Restartable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t Recordset::GetValidationText ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationText(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Recordset::GetValidationRule ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_ValidationRule(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline SAFEARRAY * Recordset::GetCacheStart ( ) {
    SAFEARRAY * _result = 0;
    HRESULT _hr = get_CacheStart(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutCacheStart ( SAFEARRAY * * ppsa ) {
    HRESULT _hr = put_CacheStart(ppsa);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Recordset::GetCacheSize ( ) {
    long _result = 0;
    HRESULT _hr = get_CacheSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutCacheSize ( long pl ) {
    HRESULT _hr = put_CacheSize(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline float Recordset::GetPercentPosition ( ) {
    float _result = 0;
    HRESULT _hr = get_PercentPosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutPercentPosition ( float pd ) {
    HRESULT _hr = put_PercentPosition(pd);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Recordset::GetAbsolutePosition ( ) {
    long _result = 0;
    HRESULT _hr = get_AbsolutePosition(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutAbsolutePosition ( long pl ) {
    HRESULT _hr = put_AbsolutePosition(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Recordset::GetEditMode ( ) {
    short _result = 0;
    HRESULT _hr = get_EditMode(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GetODBCFetchCount ( ) {
    long _result = 0;
    HRESULT _hr = get_ODBCFetchCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GetODBCFetchDelay ( ) {
    long _result = 0;
    HRESULT _hr = get_ODBCFetchDelay(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline DatabasePtr Recordset::GetParent ( ) {
    struct Database * _result = 0;
    HRESULT _hr = get_Parent(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline FieldsPtr Recordset::GetFields ( ) {
    struct Fields * _result = 0;
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FieldsPtr(_result, false);
}

inline IndexesPtr Recordset::GetIndexes ( ) {
    struct Indexes * _result = 0;
    HRESULT _hr = get_Indexes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return IndexesPtr(_result, false);
}

inline HRESULT Recordset::_30_CancelUpdate ( ) {
    HRESULT _hr = raw__30_CancelUpdate();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::AddNew ( ) {
    HRESULT _hr = raw_AddNew();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Recordset::OpenRecordset ( const _variant_t & Type, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenRecordset(Type, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline HRESULT Recordset::Delete ( ) {
    HRESULT _hr = raw_Delete();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::Edit ( ) {
    HRESULT _hr = raw_Edit();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::FindFirst ( _bstr_t Criteria ) {
    HRESULT _hr = raw_FindFirst(Criteria);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::FindLast ( _bstr_t Criteria ) {
    HRESULT _hr = raw_FindLast(Criteria);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::FindNext ( _bstr_t Criteria ) {
    HRESULT _hr = raw_FindNext(Criteria);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::FindPrevious ( _bstr_t Criteria ) {
    HRESULT _hr = raw_FindPrevious(Criteria);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::MoveFirst ( ) {
    HRESULT _hr = raw_MoveFirst();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::_30_MoveLast ( ) {
    HRESULT _hr = raw__30_MoveLast();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::MoveNext ( ) {
    HRESULT _hr = raw_MoveNext();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::MovePrevious ( ) {
    HRESULT _hr = raw_MovePrevious();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::Seek ( _bstr_t Comparison, const _variant_t & Key1, const _variant_t & Key2, const _variant_t & Key3, const _variant_t & Key4, const _variant_t & Key5, const _variant_t & Key6, const _variant_t & Key7, const _variant_t & Key8, const _variant_t & Key9, const _variant_t & Key10, const _variant_t & Key11, const _variant_t & Key12, const _variant_t & Key13 ) {
    HRESULT _hr = raw_Seek(Comparison, Key1, Key2, Key3, Key4, Key5, Key6, Key7, Key8, Key9, Key10, Key11, Key12, Key13);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::_30_Update ( ) {
    HRESULT _hr = raw__30_Update();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Recordset::Clone ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_Clone(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline HRESULT Recordset::Requery ( const _variant_t & NewQueryDef ) {
    HRESULT _hr = raw_Requery(NewQueryDef);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::Move ( long Rows, const _variant_t & StartBookmark ) {
    HRESULT _hr = raw_Move(Rows, StartBookmark);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::FillCache ( const _variant_t & Rows, const _variant_t & StartBookmark ) {
    HRESULT _hr = raw_FillCache(Rows, StartBookmark);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Recordset::CreateDynaset ( const _variant_t & Options, const _variant_t & Inconsistent ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateDynaset(Options, Inconsistent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr Recordset::CreateSnapshot ( const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateSnapshot(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _QueryDefPtr Recordset::CopyQueryDef ( ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = raw_CopyQueryDef(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

inline RecordsetPtr Recordset::ListFields ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_ListFields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr Recordset::ListIndexes ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_ListIndexes(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _variant_t Recordset::GetRows ( const _variant_t & NumRows ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = raw_GetRows(NumRows, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t Recordset::GetCollect ( const _variant_t & Item ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Collect(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void Recordset::PutCollect ( const _variant_t & Item, const _variant_t & pvar ) {
    HRESULT _hr = put_Collect(Item, pvar);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT Recordset::Cancel ( ) {
    HRESULT _hr = raw_Cancel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline VARIANT_BOOL Recordset::NextRecordset ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = raw_NextRecordset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GethStmt ( ) {
    long _result = 0;
    HRESULT _hr = get_hStmt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Recordset::GetStillExecuting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StillExecuting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GetBatchSize ( ) {
    long _result = 0;
    HRESULT _hr = get_BatchSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutBatchSize ( long pl ) {
    HRESULT _hr = put_BatchSize(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long Recordset::GetBatchCollisionCount ( ) {
    long _result = 0;
    HRESULT _hr = get_BatchCollisionCount(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _variant_t Recordset::GetBatchCollisions ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_BatchCollisions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline ConnectionPtr Recordset::GetConnection ( ) {
    struct Connection * _result = 0;
    HRESULT _hr = get_Connection(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionPtr(_result, false);
}

inline void Recordset::PutRefConnection ( struct Connection * ppCn ) {
    HRESULT _hr = putref_Connection(ppCn);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short Recordset::GetRecordStatus ( ) {
    short _result = 0;
    HRESULT _hr = get_RecordStatus(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Recordset::GetUpdateOptions ( ) {
    long _result = 0;
    HRESULT _hr = get_UpdateOptions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Recordset::PutUpdateOptions ( long pl ) {
    HRESULT _hr = put_UpdateOptions(pl);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline HRESULT Recordset::CancelUpdate ( long UpdateType ) {
    HRESULT _hr = raw_CancelUpdate(UpdateType);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::Update ( long UpdateType, VARIANT_BOOL Force ) {
    HRESULT _hr = raw_Update(UpdateType, Force);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Recordset::MoveLast ( long Options ) {
    HRESULT _hr = raw_MoveLast(Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

//
// interface _QueryDef wrapper method implementations
//

inline _variant_t _QueryDef::GetDateCreated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_DateCreated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _variant_t _QueryDef::GetLastUpdated ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_LastUpdated(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline _bstr_t _QueryDef::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _QueryDef::PutName ( _bstr_t pbstr ) {
    HRESULT _hr = put_Name(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short _QueryDef::GetODBCTimeout ( ) {
    short _result = 0;
    HRESULT _hr = get_ODBCTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _QueryDef::PutODBCTimeout ( short ps ) {
    HRESULT _hr = put_ODBCTimeout(ps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline short _QueryDef::GetType ( ) {
    short _result = 0;
    HRESULT _hr = get_Type(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _QueryDef::GetSQL ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_SQL(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _QueryDef::PutSQL ( _bstr_t pbstr ) {
    HRESULT _hr = put_SQL(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _QueryDef::GetUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Updatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline _bstr_t _QueryDef::GetConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Connect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline void _QueryDef::PutConnect ( _bstr_t pbstr ) {
    HRESULT _hr = put_Connect(pbstr);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _QueryDef::GetReturnsRecords ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_ReturnsRecords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _QueryDef::PutReturnsRecords ( VARIANT_BOOL pb ) {
    HRESULT _hr = put_ReturnsRecords(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline long _QueryDef::GetRecordsAffected ( ) {
    long _result = 0;
    HRESULT _hr = get_RecordsAffected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline FieldsPtr _QueryDef::GetFields ( ) {
    struct Fields * _result = 0;
    HRESULT _hr = get_Fields(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return FieldsPtr(_result, false);
}

inline ParametersPtr _QueryDef::GetParameters ( ) {
    struct Parameters * _result = 0;
    HRESULT _hr = get_Parameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ParametersPtr(_result, false);
}

inline HRESULT _QueryDef::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr _QueryDef::_30_OpenRecordset ( const _variant_t & Type, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw__30_OpenRecordset(Type, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr _QueryDef::_30__OpenRecordset ( const _variant_t & Type, const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw__30__OpenRecordset(Type, Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline _QueryDefPtr _QueryDef::_Copy ( ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = raw__Copy(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

inline HRESULT _QueryDef::Execute ( const _variant_t & Options ) {
    HRESULT _hr = raw_Execute(Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT _QueryDef::Compare ( struct _QueryDef * pQdef, short * lps ) {
    HRESULT _hr = raw_Compare(pQdef, lps);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr _QueryDef::CreateDynaset ( const _variant_t & Options, const _variant_t & Inconsistent ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateDynaset(Options, Inconsistent, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr _QueryDef::CreateSnapshot ( const _variant_t & Options ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_CreateSnapshot(Options, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr _QueryDef::ListParameters ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_ListParameters(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline PropertyPtr _QueryDef::CreateProperty ( const _variant_t & Name, const _variant_t & Type, const _variant_t & Value, const _variant_t & DDL ) {
    struct Property * _result = 0;
    HRESULT _hr = raw_CreateProperty(Name, Type, Value, DDL, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return PropertyPtr(_result, false);
}

inline RecordsetPtr _QueryDef::OpenRecordset ( const _variant_t & Type, const _variant_t & Options, const _variant_t & LockEdit ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenRecordset(Type, Options, LockEdit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline RecordsetPtr _QueryDef::_OpenRecordset ( const _variant_t & Type, const _variant_t & Options, const _variant_t & LockEdit ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw__OpenRecordset(Type, Options, LockEdit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

inline HRESULT _QueryDef::Cancel ( ) {
    HRESULT _hr = raw_Cancel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline long _QueryDef::GethStmt ( ) {
    long _result = 0;
    HRESULT _hr = get_hStmt(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _QueryDef::GetMaxRecords ( ) {
    long _result = 0;
    HRESULT _hr = get_MaxRecords(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _QueryDef::PutMaxRecords ( long pMxRecs ) {
    HRESULT _hr = put_MaxRecords(pMxRecs);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL _QueryDef::GetStillExecuting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StillExecuting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long _QueryDef::GetCacheSize ( ) {
    long _result = 0;
    HRESULT _hr = get_CacheSize(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void _QueryDef::PutCacheSize ( long lCacheSize ) {
    HRESULT _hr = put_CacheSize(lCacheSize);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline _variant_t _QueryDef::GetPrepare ( ) {
    VARIANT _result;
    VariantInit(&_result);
    HRESULT _hr = get_Prepare(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _variant_t(_result, false);
}

inline void _QueryDef::PutPrepare ( const _variant_t & pb ) {
    HRESULT _hr = put_Prepare(pb);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

//
// interface Recordsets wrapper method implementations
//

inline RecordsetPtr Recordsets::GetItem ( const _variant_t & Item ) {
    struct Recordset * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

//
// interface Connection wrapper method implementations
//

inline _bstr_t Connection::GetName ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Name(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline _bstr_t Connection::GetConnect ( ) {
    BSTR _result = 0;
    HRESULT _hr = get_Connect(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _bstr_t(_result, false);
}

inline DatabasePtr Connection::GetDatabase ( ) {
    struct Database * _result = 0;
    HRESULT _hr = get_Database(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return DatabasePtr(_result, false);
}

inline long Connection::GethDbc ( ) {
    long _result = 0;
    HRESULT _hr = get_hDbc(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline short Connection::GetQueryTimeout ( ) {
    short _result = 0;
    HRESULT _hr = get_QueryTimeout(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline void Connection::PutQueryTimeout ( short pSeconds ) {
    HRESULT _hr = put_QueryTimeout(pSeconds);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
}

inline VARIANT_BOOL Connection::GetTransactions ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Transactions(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline long Connection::GetRecordsAffected ( ) {
    long _result = 0;
    HRESULT _hr = get_RecordsAffected(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Connection::GetStillExecuting ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_StillExecuting(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline VARIANT_BOOL Connection::GetUpdatable ( ) {
    VARIANT_BOOL _result = 0;
    HRESULT _hr = get_Updatable(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _result;
}

inline QueryDefsPtr Connection::GetQueryDefs ( ) {
    struct QueryDefs * _result = 0;
    HRESULT _hr = get_QueryDefs(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return QueryDefsPtr(_result, false);
}

inline RecordsetsPtr Connection::GetRecordsets ( ) {
    struct Recordsets * _result = 0;
    HRESULT _hr = get_Recordsets(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetsPtr(_result, false);
}

inline HRESULT Connection::Cancel ( ) {
    HRESULT _hr = raw_Cancel();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline HRESULT Connection::Close ( ) {
    HRESULT _hr = raw_Close();
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline _QueryDefPtr Connection::CreateQueryDef ( const _variant_t & Name, const _variant_t & SQLText ) {
    struct _QueryDef * _result = 0;
    HRESULT _hr = raw_CreateQueryDef(Name, SQLText, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _QueryDefPtr(_result, false);
}

inline HRESULT Connection::Execute ( _bstr_t Query, const _variant_t & Options ) {
    HRESULT _hr = raw_Execute(Query, Options);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return _hr;
}

inline RecordsetPtr Connection::OpenRecordset ( _bstr_t Name, const _variant_t & Type, const _variant_t & Options, const _variant_t & LockEdit ) {
    struct Recordset * _result = 0;
    HRESULT _hr = raw_OpenRecordset(Name, Type, Options, LockEdit, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}

//
// interface Connections wrapper method implementations
//

inline ConnectionPtr Connections::GetItem ( const _variant_t & Item ) {
    struct Connection * _result = 0;
    HRESULT _hr = get_Item(Item, &_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return ConnectionPtr(_result, false);
}

//
// interface Recordset2 wrapper method implementations
//

inline RecordsetPtr Recordset2::GetParentRecordset ( ) {
    struct Recordset * _result = 0;
    HRESULT _hr = get_ParentRecordset(&_result);
    if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
    return RecordsetPtr(_result, false);
}
